# Unicode
1. 美国人首先对英文字符进行编码，也就是最早的ASCII码，用一个字符低7位表示英文128个字符，高1位统一为0
2. 后来欧洲人发现128位不够用，比如法国的字母上有注音符，所以把高1位编进来，可表示256个字符(ISO-8859-1)
3. 但是即使位数少，不同国家用不同的编码，0-127是一样的，在128-255这段都不一样，即使是2进制完全一样，字符完全不同，比如135，
在法语，希伯来语，俄语编码中的字符完全不同。
4. 更麻烦的是中国得到电脑科技以后，10万多汉字，256个字符是不够用的，GB2312编码用2个字节来表示绝大部分汉字，最多表示65535个汉字，
所以导致有些汉字在电脑里打不出来。
5. 所以为了统一，就发明了Unicode，将世界上所有的符号纳入电脑中，可容纳100多万字符，每个字符编码都独一无二。
6. Unicode没有规定如何存储，x86和cmd体系结构的电脑是无法分清Unicode还是ASCII的。如果规定每个字符用三或四个节表示，那英文或数字
必然有二到三个字节是0。文件会大出三倍。对于存储是极大的浪费。
7. UTF-8就是Unicode最重要的实现方式之一，还有UTF-16,UTF-32。UTF-8不是固定字节长编码的，而是一种变长的编码方式。如果一个字节
的第一位是0，则这个字符就单独占用一个字节，如果第一位是1，则连续有多少个1就占用多少个字节。UTF8是为传送Unicode而想出来的“再编码”方法罢了。
8. 注意Unicode编码和UTF-8的编码是不同的，例如‘严’字的Unicode码是4E25，UTF-8的编码是E4B8A5，UTF-8不仅考虑了编码，还考虑了存储，E4B8A5是存储识别编码基础上还塞进了4E25。  
9. [Unicode Wiki](https://en.wikipedia.org/wiki/Plane_%28Unicode%29)
10. 常规来看，中文汉字在UTF-8编码中占几个字节，一般是三个字节。
> 1110 xxxx 10xxxxxx 10xxxxxx
11. 目前Unicode字元为17组编排，每组称为平面，每个平面拥有65535个代码点，现在只用了少数平面。


# Java中的编码
1. 语言内码只有16bit（char），实际上支持不了四字节汉字，范围是Unicode 0 - Unicode 2^16 - 1
2. Character可以表示更高平面的字符，但是String处理字符长度有缺陷。导致一个字符长度为2。

```
Unicode起源于90年代初，Java略晚，Java在那个时代就开始支持Unicode，那是非常的高瞻远瞩了。
遗憾的是，Unicode（UCS）早期认为只要2个字节就能囊括地球上所有字符了，Java可能受此影响，也只给char定义了2个字节。
慢慢的UCS意识到2个字节搞不定了，开始各种打补丁，直到2003年左右，发布4.0版才正式支持4字节的字符。
那时候Java语言不仅已经成熟，而且满世界都在使用了，要把char改成4字节的风险估计大到不敢想了。
同期，也是进入21世纪之后，中日韩等汉字地区的古籍整理工作开始井喷（当然也受益于UCS的日渐成熟），
加入到UCS的字符也越来越多，这是一个互相促进的过程，同时也需要操作系统、字处理软件、字体等
的同步发展。目前UCS的扩展区已经包含了大量的四字节字符，包括古汉语、藏蒙维文字、emoji等。
```

# Base64
1. X509证书公钥也好，电子邮件也好，经常用Base64编码，计算机中任何数据都有ASCII码存储的，而ASCII码的128位-255位是不可减
字符，而网络交换上，比如说从A地传到B地，往往还要经过多个路由设备，由不同的设备对字符处理方式不同，这样那些不可见字符有可能
被处理错误，这是不利传输的，所以就把数据先做一个Base64编码，统统变成了可见字符，这样出错的可能性就大大减少了。
2. 对于证书来书哦，特别是根证书，一般都是Base64编码的，因为要被网上多人下载，电子邮件的附件一般也作Base64编码，因为一个附件
往往具有不可见字符。
3. 任何一个字符都可以看作byte，如：
01000100 10111010 01101101 110101100
那我们取6位为一组，计算ASCII，得到一个字符，这个字符肯定是可见字符，如此计算下去，知道最后完成编码
4. 对照表  

数值 | 字符 | 数值 | 字符 | 数值 | 字符 | 数值 | 字符 | 数值 | 字符 | 数值 | 字符 
-|-|-|-|-|-|-|-|-|-|-|-
0 | A | 1 | B | 2 | C | 3 | D | 4 | E | 5 | F | 
6 | G | 7 | H | 8 | I | 9 | J | 10 | k | 11 | L | 
12 | M | 13 | N | 14 | O | 15 | P | 16 | Q | 17 | R | 
18 | S | 19 | T | 20 | U | 21 | V | 22 | W | 23 | X | 
24 | Y | 25 | Z | 26 | a | 27 | b | 28 | c | 29 | d | 
30 | e | 31 | f | 32 | g | 33 | h | 34 | i | 35 | j | 
36 | k | 37 | l | 38 | m | 39 | n | 40 | o | 41 | p | 
42 | q | 43 | r | 44 | s | 45 | t | 46 | u | 47 | v | 
48 | w | 49 | x | 50 | y | 51 | z | 52 | 0 | 53 | 1 | 
54 | 2 | 55 | 3 | 56 | 4 | 57 | 5 | 58 | 6 | 59 | 7 | 
60 | 8 | 61 | 9 | 62 | + | 63 | / |    |   |    |   | 

5. 标准的Base64只有64个字符，（英文，大写小写，数字，+， /，后缀等号=）
6. Base64是吧3个字节编程4个可打印字符，所以base64编码后的字符串一定能被4整除（不算用作后缀的等号）
7. 等号一定用做后缀，且数目一定是0,1,2个。这是因为如果原文长度不能被3整除，base64要在后面添加\0来
凑齐3n位，为了正确还原，添加了几个\0就加上几个等号，凑齐3n位。
8. Base64不是加密，只能是编码转换。
9. 场景：http请求中的Key，Value必是进行URLEncode编码，不然出现等号符号导致解析失败，空格也会导致
解析出问题。
10. 例子：‘中文@#￥%……&*bc’通过编码之后值：5Lit5paHQCPw6v140Cm40CmJiPiYw==
